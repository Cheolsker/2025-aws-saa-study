
# 오답체크

# 1번
## 정답
- B

## 근거
- A ❌
  - `Amazon ElastiCache for Memcached`
    - Memcached는 Redis에 비해 일반적으로 단순하며, 복제 및 자동 장애 조치 기능이 제한적
    - 샤딩(Sharding)을 통해 확장되지만, Redis처럼 내장된 고가용성 메커니즘이 강하지 않음

- B ✅
  - `Amazon ElastiCache for Redis`
    - 고가용성 및 내구성: Redis는 복제(Replication) 기능을 제공하여 읽기 복제본을 생성할 수 있으며, Redis Cluster를 통해 **자동 장애 조치(Automatic Failover)**를 지원하여 높은 가용성을 제공
    - 데이터 보존: Redis는 데이터 영속성(Persistence) 옵션을 지원하여 메모리뿐만 아니라 디스크에도 데이터를 저장할 수 있어 데이터 손실 위험을 줄임
    - 성능: 인메모리 데이터 저장소로서 매우 빠르고 낮은 지연 시간을 제공하므로, 세션 상태 저장소로 적합

- C ❌
  - `AWS Storage Gateway 캐시 볼륨`
    - 온프레미스 환경과 AWS 클라우드 스토리지(S3 등)를 연결하는 데 사용되는 서비스
    - 웹 애플리케이션의 세션 상태를 저장하기 위한 인메모리 또는 NoSQL 데이터베이스 솔루션이 아니며, 성능과 접근 방식 면에서 부적합

- D ❌
  - `Amazon RDS`
    - RDS는 관계형 데이터베이스로, 세션 상태를 저장하는 데 사용할 수 있지만, 인메모리 데이터 저장소인 ElastiCache에 비해 지연 시간이 훨씬 높음.
    - 매우 낮은 지연 시간이 요구되는 세션 상태 저장소에는 Redis 또는 Memcached와 같은 인메모리 캐시 솔루션이 성능 면에서 훨씬 더 적합



# 2번
## 정답
- D

# 문제의 원인
- 1. 메시지 수신 및 처리 시작: EC2 인스턴스가 SQS 대기열에서 메시지를 수신. 이 순간부터 해당 메시지는 가시성 시간 초과 기간 동안 다른 컨슈머에게 보이지 않게 됨.
- 2. 처리 지연 및 시간 초과: 애플리케이션이 메시지를 처리(RDS 테이블에 쓰기)하는 데 걸리는 시간이 SQS에 설정된 가시성 시간 초과보다 길어짐.
- 3. 메시지 재노출: 가시성 시간 초과가 만료되면, 메시지는 자동으로 대기열로 돌아와 다시 보이게 됨. (메시지가 삭제되지 않았기 때문)
- 4. 중복 처리 및 레코드 발생: 다른 EC2 인스턴스(또는 동일 인스턴스)가 이 다시 노출된 메시지를 수신하여 처리하고, 이미 처리 중이거나 처리된 레코드를 RDS 테이블에 다시 쓰게 되어 중복 레코드가 발생.


## 근거
- A ❌
  - 기존 대기열의 설정을 변경하는 것이 더 적절하며, 새 대기열을 생성하는 것 자체가 중복 처리 문제를 해결못함

- B ❌
  - 권한 문제는 메시지를 수신하거나 삭제할 수 없는 인증/인가 문제를 일으킬 뿐, 중복 처리 문제를 직접적으로 유발하지 않음.

- C ❌
  - ReceiveMessage 호출의 긴 폴링(Long Polling) 대기 시간은 SQS에서 메시지를 효율적으로 가져오도록 돕는 것이지, 메시지 처리 중 중복 발생을 막는 가시성 시간 초과와는 다른 개념.

- D ✅
  - 메시지 처리가 예상되는 최대 시간보다 훨씬 길게 가시성 시간 초과를 설정하거나, 메시지 처리 중에 ChangeMessageVisibility API를 사용하여 가시성 시간 초과를 연장해야 함.
  - 이렇게 하면 처리 완료 및 DeleteMessage API 호출 전에 메시지가 대기열로 돌아가 중복 처리를 유발하는 것을 방지



# 3번
## 정답
- B

## 근거
- A ❌
  - mysqldump 방식은 현재 지연을 유발하는 원인이므로, 솔루션이 될 수 없음. Aurora를 사용하더라도 mysqldump는 프로덕션 라이터(Writer) 인스턴스에 부하를 줍니다.

- B ✅
  - `Amazon Aurora MySQL 및 Multi-AZ Aurora Replicas`
    - 고가용성 및 탄력성: Multi-AZ 구성의 Aurora Replicas는 자동 장애 조치 및 향상된 가용성을 제공하여 애플리케이션의 탄력성을 높임.
    - 읽기 부하 분산: Aurora Replicas는 읽기 트래픽을 분산하여 프로덕션 라이터 인스턴스의 부하를 줄임
    - 빠른 데이터 내보내기/복제: Aurora는 스토리지 계층 복제를 사용하며, 클론(Clone) 기능을 사용하여 데이터베이스의 사본을 빠르게 생성할 수 있음. 이는 프로덕션 라이터(Writer) 인스턴스에 미치는 영향이 적습니다.

- C ❌
  - `Multi-AZ의 스탠바이 인스턴스`
    - 장애 조치를 위한 것이지, 읽기 복제본처럼 직접 읽기 트래픽을 처리하거나 스테이징 데이터베이스로 사용할 수 없음
    - 또한 RDS for MySQL은 Aurora만큼 스냅샷 기반 복제 또는 클론 기능이 빠르고 효율적이지 않음.

- D ✅
  - A와 마찬가지로  mysqldump 방식은 지연을 유발



# 4번
## 정답
- A, E

# 요구사항
- 고가용성 (Auto Scaling Group, Multi-AZ 사용).
- 보안: EC2 인스턴스 및 RDS DB 인스턴스는 퍼블릭 인터넷에 노출되어서는 안 됩니다.

## 근거
- A ✅
  - EC2 보안 충족: EC2 인스턴스를 프라이빗 서브넷에 배치하여 퍼블릭 인터넷 노출을 방지
  - RDS 보안 및 가용성 충족: RDS DB 인스턴스를 프라이빗 서브넷에 Multi-AZ로 배포하여 퍼블릭 인터넷 노출을 방지하고 고가용성을 확보
  - 고가용성 충족: Auto Scaling Group과 Multi-AZ가 고가용성을 제공

- B ❌
  - 로드 밸런서를 프라이빗 서브넷에 배포하면 인터넷에서 접속할 수 없게 되므로 웹사이트 액세스가 불가능.
  - 또한 EC2 인스턴스에서 인터넷으로의 아웃바운드 액세스를 위해 NAT Gateway가 필요하지만, 인바운드 트래픽을 위한 인터넷 게이트웨이(IGW)에 대한 설명이 빠져있음.

- C ❌
  - 보안적으로 EC2 인스턴스는 퍼블릭 인터넷에 노출되어서는 안됨

- D ❌
  - 두 AZ에서 고가용성을 보장하려면 일반적으로 각 AZ에 퍼블릭/프라이빗 서브넷 쌍이 있어야 하며, 각 AZ에 NAT Gateway가 있어야 함.
  - 하나의 퍼블릭 서브넷과 하나의 프라이빗 서브넷만 있다면 고가용성 요구 사항을 충족하기 어려움. 또한 두 개의 AZ에 두 개의 NAT Gateway를 구성하려면 최소한 두 개의 퍼블릭 서브넷이 필요.

- E ✅
  - 고가용성 (두 AZ): 두 개의 가용성 영역(AZ)에 걸쳐 서브넷을 구성하여 고가용성을 지원
  - 트래픽 진입점: **Application Load Balancer (ALB)**는 일반적으로 인터넷 트래픽을 수신해야 하므로 퍼블릭 서브넷에 배포되어야 함.
  - 인터넷 액세스: 프라이빗 서브넷에 있는 EC2 인스턴스가 인터넷에 접속하려면 NAT Gateway가 필요. 이 게이트웨이는 고가용성을 위해 각 AZ의 퍼블릭 서브넷에 하나씩, 총 두 개를 구성하는 것이 최적의 방법.



# 11번
## 정답
- C

# 요구사항
- 전송 중 암호화: 모든 보호된 건강 정보(PHI)가 **전송 중(in transit)**에 암호화
- 저장 중 암호화 및 키 관리: 모든 PHI가 **저장 중(at rest)**에 암호화되어야 하며, 컴플라이언스 팀이 암호화 키를 관리

## 근거
- A ✅
  - ACM 인증서는 S3 버킷이 아닌 로드 밸런서(ALB/CLB) 또는 CloudFront와 같은 서비스에 연결하여 HTTPS를 활성화하는 데 사용
  - S3 자체의 기본 엔드포인트에 대한 전송 중 암호화는 S3 버킷 정책의 aws:SecureTransport 조건으로 제어하는 것이 일반적
  - SSE-KMS 사용은 옳지만, ACM 부분은 불필요하거나 부정확함.

- B ❌
  - SSE-S3는 AWS가 키를 관리하는 암호화 방식. **"컴플라이언스 팀이 저장 중인 데이터에 대한 암호화 키를 관리해야 합니다."**라는 핵심 요구 사항을 SSE-S3는 충족하지 못함.

- C ❌
  - 1. 전송 중 암호화 (AWS:SecureTransport)S3 버킷 정책에서 aws:SecureTransport 조건을 사용
    - 이 조건을 사용하면 Amazon S3에 대한 모든 요청이 **HTTPS(TLS)**를 통해서만 허용됨. 
    - TLS는 데이터를 전송하는 동안 암호화하므로 전송 중 암호화 요구 사항을 충족.
  - 2. 저장 중 암호화 및 키 관리 (SSE-KMS)AWS KMS 키 ($\text{SSE-KMS}$)로 서버 측 암호화를 사용
    - SSE-KMS는 데이터를 S3에 저장할 때 암호화하고 검색할 때 복호화하는 서버 측 암호화 방식
    - 저장 중 암호화: 데이터를 디스크에 저장하기 전에 암호화하므로 저장 중 암호화 요구 사항을 충족.
    - 키 관리: SSE-KMS를 사용하면 고객이 AWS Key Management Service (KMS)를 통해 **고객 관리형 키 (Customer Managed Key, CMK)**를 생성하고 관리할 수 있음
    - 이를 통해 컴플라이언스 팀이 암호화 키를 관리하고 사용 권한을 감사할 수 있음.

- D ❌
  - Amazon Macie는 민감한 데이터를 탐지하고 분류하는 보안 및 데이터 거버넌스 서비스이지, 암호화 키 관리를 직접 수행하는 서비스가 아님

